#!/bin/sh
# Based on https://github.com/ericpaulbishop/cp_p
# and https://unix.stackexchange.com/questions/44040/a-standard-tool-to-convert-a-byte-count-into-human-kib-mib-etc-like-du-ls1

H_FUN='
function human(x) {
    if (x < 0) {
       return "..."
    }
    s=" B   KiB MiB GiB TiB EiB PiB YiB ZiB"
    while (x >= 1024 && length(s) > 1) {
        x /= 1024
        s = substr(s, 5)
    }
    s = substr(s, 1, 4)
    xf = (s == " B  ") ? "%d" : "%.2f"
    return sprintf(xf"%s", x, s)
}
function human_time(t) {
    if (t < 0) {
       return "..."
    }
    h = int(t / 3600)
    m = int(t / 60) % 60
    s = t % 60
    if (h == 0) {h = ""} else {h = sprintf("%dh ", h)}
    if (m == 0) {m = ""} else {m = sprintf("%dm ", m)}
    return sprintf("%s%s%.1fs", h, m, s)
}'

help() {
    orig=$(echo "$cmd" | head -n1)
    echo "Usage: ${orig}-p [OPTION]... SOURCE DEST"
    echo "Like ${orig} but with progress information."
    echo
    echo "  -F FILE     read source paths from FILE"
    echo "  --new-line  show every progress step in a new line"
    echo "  --no-timing suppress timing information"
    echo "  --lf-paste  to be used for lf file manager."
    echo "              Add 'cmd paste \$cp-p --lf-paste \$id' to"
    echo "              ~/.config/lf/lfrc"
    echo "  --help      display this help and exit"
    echo
    echo "Check ${orig} --help for more options."

    exit 1
}

err() {
    printf '%s-p: %s\n' "$(echo "$cmd" | head -n1)" "$2" 1>&2
    [ "$1" -gt 0 ] && exit $1
}

main() {
    if [ "$1" = '--lf-paste' ]; then
        shift
        lf_paste "$@"
        return
    fi

    # ARGS STUFF

    mv_opt=0
    new_line_opt=0
    no_timing_opt=0
    help_opt=0
    end_of_opts=0

    srcs=''
    srcF=''
    dest=''
    last=''
    opts=''

    while [ $# -gt 0 ]; do
        arg=$1
        shift
        if [ $end_of_opts -eq 0 ]; then
            case "$arg" in
                -F) if [ $# -gt 0 ]; then
                        srcF=$1; shift; continue
                    else
                        err 1 "'F' option requires an argument"
                    fi ;;
                -t) if [ $# -gt 0 ]; then
                        dest=$1; shift; continue
                    else
                        err 1 "'t' option requires an argument"
                    fi ;;
                --mv) mv_opt=1; continue ;;
                --new-line) new_line_opt=1; continue ;;
                --no-timing) no_timing_opt=1; continue ;;
                --help) help_opt=1; continue ;;
                --) end_of_opts=1; continue ;;
                -*) opts=$(printf '%s\n%s' "$opts" "$arg"); continue ;;
            esac
        fi
        srcs=$(printf '%s\n%s' "$srcs" "$last")
        last=$arg
    done

    if [ -z "$dest" ]; then
        dest=$last
    else
        srcs=$(printf '%s\n%s' "$srcs" "$last")
    fi

    if [ "$srcF" ]; then
        if [ ! -f "$srcF" ]; then
            err 1 "failed to access '"$srcF"': No such file"
        fi
        while read -r line; do
            srcs=$(printf '%s\n%s' "$srcs" "$line")
        done < "$srcF"
    fi

    srcs=${srcs#?}  # remove first empty line
    opts=${opts#?}  #

    if [ $mv_opt -eq 1 ]; then
        cmd='mv'
    else
        cmd='cp
-r'
    fi

    if [ $new_line_opt -eq 1 ]; then
        R='\n'
        B=''
        W=99999999
    else
        R=''
        #B='\033[0E\033[K'
        B='\r\033[K'
        W=$(tput cols)
    fi

    if [ $help_opt -eq 1 ] || [ ! "$srcs" ] || [ ! "$dest" ]; then
        help
    fi

    # THE ACTUAL THING

    printf $B'Calculating size...'$R

    realdest=$(realpath -- "$dest")

    total_size=0
    srcs_count=0
    sizes=''
    srcsE=''
    IFS='
'; for src in $srcs; do
        [ -e "$src" ] || continue
        arg_size=$(du -sb -- "$src" 2>/dev/null | awk '{print $1}')
        [ -n "$arg_size" ] || arg_size=0
        total_size=$((total_size + arg_size))
        sizes=$(printf '%s\n%s' "$sizes" "$arg_size")
        srcsE=$(printf '%s\n%s' "$srcsE" "$src")
        srcs_count=$(($srcs_count+1))
    done
    sizes=${sizes#?}  # remove first empty line
    srcs=${srcsE#?}   #
    unset srcsE

    printf $B''

    if [ "$srcs_count" -eq 0 ]; then
        err 1 "no source file specified exists. Please try again"
    fi

    if [ "$srcs_count" -gt 1 ] && [ ! -d "$realdest" ]; then
        err 1 "target '"$dest"' is not a directory"
    fi

    if [ "$srcs_count" -eq 1 ] && [ -f "$realdest" ] && [ -d "$srcs" ] && [ ! -L "$srcs" ] ; then
        err 1 "cannot overwrite non-directory '"$dest"' with directory '"$srcs"'"
    fi

    total_size_h=$(echo $total_size | awk "$H_FUN"'{print human($1)}')

    set -- $sizes
    unset sizes

    if [ "$cmd" = mv ]; then
        printf $B'Moving...'$R
    else
        printf $B'Copying...'$R
    fi

    count=0
    IFS='
'; for src in $srcs; do

       # if same name
       fname=${src%"${src##*[!/]}"}
       fname=${fname##*/} && [ -z "$fname" ] && fname='/'
       finaldest=$realdest
       if [ -e "$finaldest/$fname" ]; then
           body=${fname%.*}
           body=${body%.tar}
           ext=${fname#$body}
           copy_n=
           # keep looping till a new name is found
           while :; do
               finaldest="${realdest}/${body}-copy${copy_n}${ext}"
               if [ ! -e "$finaldest" ]; then
                   break
               elif [ ! "$copy_n" ]; then
                   copy_n=1
               else
                   copy_n=$((copy_n + 1))
               fi
           done
       fi

       strace -q -ewrite $cmd $opts -- "$src" "$finaldest" 2>&1 |
           awk "$H_FUN"'
        BEGIN { time_start = systime() }
        {
            count += $NF
            if (total_size > 0 && count % 10 == 0) {
                time_elapsed = systime() - time_start
                if (time_elapsed == 0 || count == 0) {
                    bytes_per_sec = -1
                    eta = -1
                } else {
                    bytes_per_sec = count/time_elapsed
                    eta = (total_size - count) / bytes_per_sec
                }
                percent = (count / total_size) * 100
                printf "'$B'"substr(sprintf("%3d%% (%s/%s, %s/s, ETA: %s) %s to %s'$R'", percent, human(count), total_size_h, human(bytes_per_sec), human_time(eta), src, finaldest), 0, '$W')
            }
        }
        END { if (!no_timing) print "'$B'Took " human_time(systime() - time_start); }' \
               total_size=$total_size \
               total_size_h="$total_size_h" \
               no_timing=$no_timing_opt \
               count=$count \
               src="$src" finaldest="$finaldest"

       arg_size=$1
       count=$((count + arg_size))
       shift
   done

   [ $no_timing_opt -eq 1 ] && printf $B''

    if [ "$cmd" = mv ]; then
        echo 'Done moving'
    else
        echo 'Done copying'
    fi

}

# to be used only for `lf` file manager. cp-p and mv-p must be on $PATH
lf_paste() {
    id="$1"
    # permissions: auto (default), user, sudo
    case "${2:-}" in
        sudo) s='sudo' ;;
        user) s='' ;;
        *) s='' && [ ! -w . ] && s='sudo' ;;
    esac
    [ -e ~/.local/share/lf/files ] || exit 0
    tmpdir=${XDG_RUNTIME_DIR:-${TMPDIR:-/tmp}}
    srcF=$(mktemp $tmpdir/lfpaste.XXXXXXXX)
    sed '1d' ~/.local/share/lf/files > "$srcF"
    mode=$(sed -n '1p' ~/.local/share/lf/files)
    case "$mode" in
        copy) cmd='cp-p --new-line --no-timing -a' ;;
        move) cmd='cp-p --mv --new-line --no-timing' ;;
        *) rm -f "$srcF"; exit 0 ;;
    esac
    send="(while read -r line; do lf -remote \"send $id echo \$line\"; last=\$line; done && lf -remote 'send reload' && lf -remote \"send $id echo \$last\")"
    sh -c "$s $cmd --backup=numbered -F \"$srcF\" . | $send && rm -f \"$srcF\" &"
    #rm ~/.local/share/lf/files
    lf -remote 'send clear'
}

main "$@"
